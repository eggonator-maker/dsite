# price_importer Module — Development Summary

## Overview

The `price_importer` module was built to manage the medical prices displayed on the `/preturi` page of the Spital Nord Muntenia website. Before this module existed, prices were stored as a hand-crafted hierarchy of paragraph entities in the CMS with no programmatic update path.

The module provides:
- Two import methods: **CSV file upload** and **direct API fetch** from `medapi.ro`
- A **Drush CLI interface** for server-side or scheduled imports
- An **admin UI** at `/admin/config/content/price-import`
- A **performance-first storage model** — the entire price tree is kept as a single JSON blob rather than thousands of paragraph entities

---

## Module Location

```
web/modules/custom/price_importer/
```

Dependencies declared in `price_importer.info.yml`: `drupal:paragraphs`, `drupal:block_content`.

---

## File Structure

```
price_importer/
├── config/
│   ├── install/
│   │   └── price_importer.settings.yml       # Default config (api_token: '')
│   └── schema/
│       └── price_importer.schema.yml          # Config schema for api_token
├── src/
│   ├── Commands/
│   │   └── PriceImporterCommands.php          # Drush commands (price-import:api, price-import:csv)
│   ├── DataTransfer/
│   │   ├── ImportData.php                     # Root DTO — holds MainCategory[]
│   │   ├── MainCategory.php                   # name, isExpanded, subcategories[]
│   │   ├── SubCategory.php                    # name, anchorId, displayMode, serviceGroups[], directItems[]
│   │   ├── ServiceGroup.php                   # name, items[]
│   │   └── PriceItem.php                      # displayName, price, appointmentUrl
│   ├── Exception/
│   │   └── PriceImportException.php           # Extends \RuntimeException
│   ├── Form/
│   │   └── PriceImportForm.php                # Admin form (CSV upload, API import, token settings)
│   └── Service/
│       ├── ApiClientService.php               # Fetches and structures data from medapi.ro
│       ├── CsvParserService.php               # Parses CSV files into the DTO tree
│       └── PriceImporterService.php           # Orchestrates import: stores JSON, busts cache
├── tests/
│   └── Unit/
│       ├── ApiClientServiceTest.php           # Token resolution, header building, HTTP mocking
│       ├── CsvParserServiceTest.php           # Parsing edge cases, price formats, anchor IDs
│       └── PriceImporterServiceTest.php       # Guard clauses, block lookup, paragraph deletion
├── drush.services.yml                         # Registers PriceImporterCommands as drush.command
├── price_importer.info.yml
├── price_importer.module                      # hook_preprocess_block — injects prices_data
├── price_importer.permissions.yml             # administer price importer
├── price_importer.routing.yml                 # /admin/config/content/price-import
└── price_importer.services.yml               # Service definitions
```

---

## CSV Format

The CSV must be UTF-8 encoded with a header row. Column order does not matter — columns are matched by name.

```
main_category,subcategory,service_group,display_name,price,appointment_url
Laborator,Lab Muntenia Medical Competences,Hemograma,Hemoleucograma completa,25,
Ambulatoriu,Anestezie,Anestezie generala,Gatita Codrut-Emilian,825,https://...
```

**Column semantics:**

| Column | Required | Notes |
|---|---|---|
| `main_category` | Yes | Top-level category (e.g. "Laborator", "Ambulatoriu") |
| `subcategory` | Yes | Second level (e.g. specialty name, lab name) |
| `service_group` | No | If non-empty → `service_groups` mode (accordion); if empty → `direct_items` mode (flat list) |
| `display_name` | Yes | Item label (doctor name, test name, etc.) |
| `price` | No | Decimal value; handles Romanian `1.234,56` and English `1,234.56` formats |
| `appointment_url` | No | Optional booking link |

The first `main_category` encountered is automatically marked as expanded in the sidebar accordion.

---

## Data Transfer Objects

The import pipeline uses an internal DTO tree to decouple parsing from persistence:

```
ImportData
  └─ MainCategory[]          (name, isExpanded)
       └─ SubCategory[]      (name, anchorId, displayMode)
            ├─ ServiceGroup[] → PriceItem[]   (service_groups mode)
            └─ directItems[]  → PriceItem[]   (direct_items mode)
```

`anchorId` is generated by `generateAnchorId()`, which mirrors the `clean_id` Twig filter in the theme — Romanian characters are transliterated and spaces become dashes, prefixed with `group-`.

---

## Services

### `CsvParserService`

Parses a CSV file (or string) into `ImportData`. Key behaviours:

- Validates that required columns (`main_category`, `subcategory`, `display_name`, `price`) exist
- Skips rows with blank required fields
- `parsePrice()` handles both Romanian (`1.234,56`) and English (`1,234.56`) decimal formats
- Display mode is inferred per subcategory: any non-empty `service_group` value in that group → `service_groups`, otherwise `direct_items`

### `ApiClientService`

Mirrors the Python `price_scrape.py` logic entirely in PHP. Key behaviours:

- Fetches lab services via `GET /sync/lab-muntenia`
- Fetches doctor list via `GET /sync/doctor-muntenia`, then POSTs to `/sync/doctor-muntenia/details` for each doctor (with 0.1s rate-limiting delay)
- Maps lab data to `main_category = "Laborator"` and doctor data to `main_category = "Ambulatoriu"`
- `resolveToken()`: checks `MEDAPI_TOKEN` env var first, then the `price_importer.settings` config; returns empty string if neither is set (the API is then called without an `Authorization` header)
- `buildHeaders()`: only adds `Authorization: Bearer …` when a token is present

### `PriceImporterService`

Orchestrates the import. Key behaviours:

1. Validates `ImportData` is not empty
2. Locates the `prices_block` block content entity
3. Deletes any legacy paragraph entities (BFS via `paragraphs_item_field_data` table in chunks of 100)
4. Serialises `ImportData` to a snake_case array and JSON-encodes it
5. Stores JSON in `\Drupal::state()` under key `prices_block.json`
6. Saves the block content entity (with empty `field_main_categories`) to invalidate its cache tags and clear the page cache

---

## Drush Commands

```bash
# Import from the live API (uses MEDAPI_TOKEN env var or saved config token)
ddev drush price-import:api

# Override the token for a single run (not saved)
ddev drush price-import:api --token=abc123

# Import from a CSV file
ddev drush price-import:csv /path/to/drupal_prices_import.csv
```

Both commands log a data summary (category count, subcategory count, service groups, price items) before persisting.

---

## Admin UI

Located at `/admin/config/content/price-import` (requires `administer price importer` permission).

Three sections:
1. **Import from CSV** — file upload field + submit button
2. **Import from MedAPI** — single button, fetches live data immediately
3. **API settings** (collapsible) — saves the API bearer token to `price_importer.settings` config

---

## Performance Architecture

### The problem

When prices were stored as paragraph entities (2 main categories → 13 subcategories → 974 service groups → 2,744 price items = **3,733 entities**), Drupal's entity API loaded each one individually on every page render. This caused:

- ~26-second cold renders
- 4.8 MB HTML output
- The Drupal page cache never stored the result

### The solution

The entire price tree is serialised to a **single JSON blob** (~283 KB) stored via `\Drupal::state()->set('prices_block.json', $json)`. The block template reads this JSON directly through a preprocess hook — no paragraph entities are loaded at render time.

**`price_importer_preprocess_block()`** (in `price_importer.module`):

```php
function price_importer_preprocess_block(array &$variables): void {
    $block_content = $variables['elements']['content']['#block_content'];
    if ($block_content->bundle() !== 'prices_block') return;

    $json = \Drupal::state()->get('prices_block.json', '');
    if ($json !== '') {
        $variables['prices_data'] = json_decode($json, TRUE);
    }
}
```

**Block template** (`block--block-content--type--prices-block.html.twig`) was rewritten to iterate over `prices_data` — a plain PHP array — using a Twig macro for price items. No `.entity` property access anywhere.

**Cache invalidation** still works correctly: the `prices_block` block content entity is saved on every import (even with an empty paragraph field), which invalidates its standard cache tags (`block_content:228`, `block_content_view`) and clears any cached page entries.

### Results

| Metric | Before | After |
|---|---|---|
| Cold render | ~26s | ~2.6s |
| Warm render | ~26s | ~0.5s |
| HTML size | 4.8 MB | 2.6 MB |
| Paragraph entities in DB | 3,733 | 0 |

Full details: [`docs/prices-block-performance-fix.md`](./prices-block-performance-fix.md)

---

## Theme Changes

| File | Change |
|---|---|
| `templates/block/block--block-content--type--prices-block.html.twig` | Fully rewritten — renders sidebar and main content from `prices_data` array using a Twig macro for price items |

The paragraph-level templates (`paragraph--price-*.html.twig`) remain in place but are no longer invoked for the prices block. They are harmless and could be removed in a future cleanup.

---

## Python Scraper Change

`content_scraper/price_scrape/price_scrape.py` — added `export_to_csv(unified_structure, output_dir)` function called at the end of `main()`. It writes `medical_data_export/drupal_prices_import.csv` in the flat format expected by `CsvParserService`. This provides an alternative to live API imports when the scraper is run offline or for data inspection.

---

## Unit Tests

Three test classes covering the three services:

- **`CsvParserServiceTest`** — basic service_groups and direct_items parsing, multiple categories, first-category expansion, price format edge cases (Romanian/English separators), anchor ID generation, column order independence, error cases (empty file, missing columns, header-only, file not found)
- **`PriceImporterServiceTest`** — empty data guard, missing prices_block guard, `findPricesBlock()` null and load paths, `collectDescendantParagraphIds()` empty and multi-level traversal, `deleteOldParagraphs()` batch deletion
- **`ApiClientServiceTest`** — token resolution priority (env var > config > empty), header building with/without token, `buildFromRows()` grouping and incomplete row skipping, `toFloat()` with various formats, `generateAnchorId()` correctness, `fetchAll()` with mocked HTTP responses

---

## Environment Setup

```bash
# DDEV project
ddev config --project-name=model-a --docroot=web --project-type=drupal11
ddev start
ddev import-db --file=db.sql.gz

# Install Drush
ddev composer require drush/drush

# Enable module
ddev drush en price_importer -y
ddev drush cr

# Run import
ddev drush price-import:api
```

- DDEV project: `model-a` → `https://model-a.ddev.site`
- Page cache TTL: `ddev drush config:set system.performance cache.page.max_age 3600`
